---
title: "2025 Advent of Code"
format: html
editor: visual
---

```{r}
library(here)
library(tidyverse)
library(janitor)
options(scipen = 999)

```

## Day 1 - Safe Password

### Part 1

```{r}


rotations <- read_tsv(here("input/day1.txt"), col_names = F) %>%
  separate_wider_regex(X1,
                       patterns = c(
      direction = "[[a-zA-Z]]+", # One or more letters
      number = "[[0-9]]+"     # One or more numbers
    )) %>%
  mutate(number = as.numeric(number))

starting_value <- 50

number_zeroes <- 0

for (i in 1:nrow(rotations)) {
  if (i == 1) {
    current_value <- starting_value
  }
  add_subtract <- rotations$direction[[[[i]]]]
  change_value <- rotations$number[[[[i]]]]
  
  if (change_value > 99) {
    change_value <- change_value %% 100 #there are 100 values available, 0-99
  }
  
  if (add_subtract == "R") {
    if (current_value + change_value > 99) {
      current_diff_from_100 <- 100 - current_value
      new_change_value <- change_value - current_diff_from_100
      current_value <- 0 + new_change_value
    } else {
      current_value <- current_value + change_value
    }
  }
  
   if (add_subtract == "L") {
    if (current_value - change_value < 0) {
      current_diff_from_0 <- abs(0 - current_value)
      new_change_value <- change_value - current_diff_from_0
      current_value <- 100 - new_change_value
    } else {
      current_value <- current_value - change_value
    }
    
    }
    if (current_value == 0) {
      number_zeroes <- number_zeroes + 1
    }
}
```

### Part 2

```{r}

dial <- c(0:99)
dial_length <- length(dial)
starting_index <- which(dial == 50)
number_zeroes <- 0

#Need to use modulos for this
for (i in 1:nrow(rotations)) {
  if (i == 1) {
    current_value <- dial[[starting_index]]
  }
  add_subtract <- rotations$direction[[[[i]]]]
  change_value <- rotations$number[[[[i]]]]
  times_past_zero <- 0
  
  if (add_subtract == "R") {
    #-----------------Dial Right on Zero
    #if the dial lands exactly on zero, add it to our tally and reset current_value
    if (current_value + change_value == 100) {
           current_value <- 0
      number_zeroes <- number_zeroes + 1
    #-----------------Dial goes past zero
    #if the dial will go past zero, how many times will it do so?
    } else if (current_value + change_value > 100) {
      #How many times will we go past zero before changing the index?
      times_past_zero <- floor(change_value/100)
      #Then get the amount to shift the index by
      shift_by <- change_value %% 100
      #if our shift_by value will bring us past zero, figure out the new index by addint 100
      if (current_value + shift_by > 99) {
        shift_past_zero <- abs(length(dial) - current_value - shift_by)
        times_past_zero <- times_past_zero + 1
        current_value <- shift_past_zero
      } else {
        current_value <- current_value + shift_by
      }
    } else {
        current_value <- current_value + change_value
      }
  } 
  
  if (add_subtract == "L") {
    #-----------------Dial Left on Zero
    #if the dial lands exactly on zero, add it to our tally and reset current_value
    if (current_value - change_value == 0) {
           current_value <- 0
      number_zeroes <- number_zeroes + 1
    #-----------------Dial goes past zero
    #if the dial will go past zero, how many times will it do so?
    } else if (current_value - change_value < 0) {
      #How many times will we go past zero before changing the index?
      times_past_zero <- floor(change_value/100)
      #Then get the amount to shift the index by
      shift_by <- change_value %% 100
      #if our shift_by value will bring us past zero, figure out the new index by addint 100
      if (current_value - shift_by < 0) {
        shift_past_zero <- abs(current_value - shift_by)
        times_past_zero <- times_past_zero + 1
        current_value <- 100 - shift_past_zero
      } else {
        current_value <- current_value - shift_by
      }
    } else {
        current_value <- current_value - change_value
      }
  }
  number_zeroes <- number_zeroes + times_past_zero
}


#1737 is too low. 6843 is not correct. Neither is 6407.


#-------------------------Try something more hacky for the time being

max_rotations <- max(rotations$number)/length(dial)
unlimited_dial <- rep(dial, 501)
starting_position <- median(which(unlimited_dial == 50))
zero_positions <- which(unlimited_dial == 0)
number_zeroes <- 0

for (i in 1:nrow(rotations)) {
  add_subtract <- rotations$direction[[[[i]]]]
  change_value <- rotations$number[[[[i]]]]
  if (i == 1) {
    current_value <- starting_position
  }
  if (add_subtract == "R") {
    prev_value <- current_value + 1 #so we don't double count when it lands exactly on zero
    current_value <- current_value + change_value
    number_zeroes <- number_zeroes + length(which(zero_positions %in% prev_value:current_value))
  }
  if (add_subtract == "L") {
    prev_value <- current_value - 1 #so we don't double count when it lands exactly on zero
    current_value <- current_value - change_value
    number_zeroes <- number_zeroes + length(which(zero_positions %in% prev_value:current_value))
  }
}

#6412 is correct!!!
```

## Day 2 - Gift Shop

### Part 1

```{r}
id_strings <- tibble(ids = read_lines(here("input/day2.txt"))) %>%
  separate_rows(ids, sep = ",") %>%
  separate(ids, into = c("range_start", "range_end"))

invalid_id_count <- 0
invalid_id_sum <- 0

for (i in 1:nrow(id_strings)) {
#for (i in 2:2) {
  range <- id_strings$range_start[[[[i]]]]:id_strings$range_end[[[[i]]]]
  
  for (j in 1:length(range)) {
    id <- range[[[[j]]]]
    #Only have to worry about even string length numbers
    if (str_length(id) %% 2 == 0) {
    first_half <- as.numeric(str_sub(id, 1, str_length(id)/2))
    second_half <- as.numeric(str_sub(id, str_length(id)/2 +1, str_length(id)))
    if (first_half == second_half) {
      invalid_id_count <- invalid_id_count + 1
      invalid_id_sum <- invalid_id_sum + id
    }
    }
  }
}

```

### Part 2

```{r}

test_for_repeats <- function(string) {
  if(str_detect(string, "^(.*)\\1+$") == TRUE) {
    return(TRUE)
  } else {
    return(FALSE)
  }
}
test_for_repeats <- Vectorize(test_for_repeats)

string_ranges <- list()

for (i in 1:nrow(id_strings)) {
  range <- id_strings$range_start[[[[i]]]]:id_strings$range_end[[[[i]]]]
  string_ranges <- c(string_ranges, list(range))
}

string_ranges <- unlist(string_ranges)

to_sum <- which(test_for_repeats(string_ranges) == T)

sum(string_ranges[[to_sum]])

```

## Day 3 - Joltage

### Part 1

```{r}
batteries <- str_split(read_lines(here("input/day3.txt")), "")

joltages <- list()

#find index of highest number that isn't the very last number, then find next highest number after that one

for (i in 1:length(batteries)) {
  vector <- as.numeric(batteries[[[[i]]]])
  #get max of the vector without the final element
  max_index <- which(vector == max(vector[[-c(length(vector))]]))[[[[1]]]]
  max_value <- max(vector[[-c(length(vector))]])
  second_max_value <- max(vector[[-c(1:max_index)]])
  
  joltage <- as.numeric(paste0(max_value, second_max_value))
  joltages <- c(joltages, list(joltage))
}

sum(unlist(joltages))

```

### Part 2

```{r}

joltages <- list()

#find index of highest number that isn't the very last number, then find next highest number after that one, and so on, 12 times, making sure there are at least the right number of digits left in the vector

for (i in 1:length(batteries)) {
  vector <- as.numeric(batteries[[[[i]]]])
  
  digit_counter <- 11
  digits <- c()
  for (j in 1:12) {
  #get max of the vector without the final n elements
  max_index <- which(vector == max(vector[[1:(length(vector)-digit_counter)]]))[[[[1]]]]
  max_value <- max(vector[[max_index:(length(vector)-digit_counter)]])
  digits <- c(digits, c(max_value))
  digit_counter <- digit_counter - 1
  vector <- vector[[(max_index + 1):length(vector)]]
  }
  digits <- as.numeric(glue::glue_collapse(digits))
  joltages <- c(joltages, list(digits))
}

sum(unlist(joltages))
```

## Day 4 - Print Rolls

### Part 1

```{r}
num_cols <- str_count(read_lines(here("input/day4.txt"), n_max = 1))
rolls <- read_tsv(here("input/day4.txt"), col_names = F) %>%
  separate(X1, into = paste0("x", 0:num_cols), sep = "") %>%
  select(-x0)

accessible_rolls <- 0

for (i in 1:nrow(rolls)) {
  
  row <- i
  
  for (j in 1:ncol(rolls)) {
    col <- j
    #Check if the current position holds a roll, and if not, skip
    if (rolls[[i,j]] == ".") {
      next
    }
    #get adjacent positions, make sure they are valid indices
    if (i == 1 & j == 1) {
      adjacent <- c(rolls[[i+1,j]], rolls[[i+1, j+1]], rolls[[i,j+1]])
    } else if (i == nrow(rolls) & j == ncol(rolls)) {
      adjacent <- c(rolls[[i-1,j]], rolls[[i-1, j-1]], rolls[[i,j-1]])
    } else if (i == 1 & j == ncol(rolls)) {
      adjacent <- c(rolls[[i+1,j]], rolls[[i+1, j-1]], rolls[[i,j-1]])
    } else if (i == nrow(rolls) & j == 1) {
      adjacent <- c(rolls[[i-1,j]], rolls[[i-1, j+1]], rolls[[i,j+1]])
    } else if (i == 1) {
      adjacent <- c(rolls[[i+1,j]], rolls[[i+1, j+1]], rolls[[i,j+1]], 
                    rolls[[i, j-1]], rolls[[i+1, j-1]])
    } else if (i == nrow(rolls)) {
      adjacent <- c(rolls[[i-1,j]], rolls[[i-1, j-1]], rolls[[i,j-1]], 
                    rolls[[i-1, j+1]], rolls[[i, j+1]])
    } else if (j == 1) {
      adjacent <- c(rolls[[i+1,j]], rolls[[i+1, j+1]], rolls[[i,j+1]],
                    rolls[[i-1, j]], rolls[[i-1, j+1]])
    } else if (j == ncol(rolls)) {
      adjacent <- c(rolls[[i-1,j]], rolls[[i-1, j-1]], rolls[[i,j-1]],
                    rolls[[i+1, j-1]], rolls[[i+1, j]])
    } else {
      adjacent <- c(rolls[[i-1,j]], rolls[[i-1, j-1]], rolls[[i,j-1]], 
                    rolls[[i-1, j+1]], rolls[[i, j+1]], rolls[[i+1, j-1]],
                    rolls[[i+1, j]], rolls[[i+1, j+1]])
    }
    
    if (sum(adjacent == "@") < 4) {
      accessible_rolls <- accessible_rolls + 1
    }
  }
}

```

### Part 2

```{r}

#Maybe try adding buffer rows and columns to the dataset to eliminate all the if statements

buffer_row <- tibble(x = rep(".", ncol(rolls) + 1)) %>%
  mutate(colnames = paste0("x", row_number()-1)) %>%
  pivot_wider(names_from = "colnames", values_from = "x") %>%
  rename("first_col" = x0) %>%
  mutate(last_col = ".")

rolls2 <- buffer_row %>%
  bind_rows(rolls %>%
  mutate(first_col = ".",
         last_col = ".") %>%
  relocate(first_col, .before = x1)) %>%
  bind_rows(buffer_row) %>%
  as.matrix(.)

rock_n_roll <- function(matrix) {
  for (i in 2:(nrow(matrix) - 1)) {
    for (j in 2:(ncol(matrix) - 1)) {
      if (i == 2 & j == 2) {
        indices_to_replace <- c()
        current_rolls_counter <- 0
      }
      if (matrix[[i,j]] == "@") {
       
      adjacent <- c(matrix[[i-1,j]], matrix[[i-1, j-1]], matrix[[i,j-1]], 
                    matrix[[i-1, j+1]], matrix[[i, j+1]], matrix[[i+1, j-1]],
                    matrix[[i+1, j]], matrix[[i+1, j+1]])
      
      if (sum(adjacent == "@") < 4) {
        accessible_rolls <<- accessible_rolls + 1
        replacement_index <- ((j-1) * nrow(matrix)) + i
        indices_to_replace <- c(indices_to_replace, replacement_index)
        current_rolls_counter <- current_rolls_counter + 1
      }
      }
      if (i == (ncol(matrix) - 1) & j == (nrow(matrix) - 1)) {
        if (current_rolls_counter == 0) {
          done <- "Finished!"
          return(done)
        } else {
        matrix[indices_to_replace] <- "."
        rock_n_roll(matrix)
        }
      }
    }
  }
}

accessible_rolls <- 0
rock_n_roll(rolls2)
accessible_rolls

```
